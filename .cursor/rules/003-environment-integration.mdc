# 环境集成指导

## 🎯 Tampermonkey 用户脚本特性

### CDN 依赖管理
- **外部依赖**：通过 `@require` 加载 CDN 资源
- **版本控制**：指定依赖的精确版本
- **加载顺序**：确保依赖按正确顺序加载
- **错误处理**：处理依赖加载失败的情况

### 浏览器环境适配
```javascript
// 用户脚本头部配置
// ==UserScript==
// @name         QQ Mind Map to Obsidian Converter
// @namespace    http://tampermonkey.net/
// @version      2.0.0
// @description  Converts QQ Mind Map to Obsidian Markdown and vice-versa
// @author       carllx & Gemini
// @match        https://docs.qq.com/mind/*
// @grant        GM_setClipboard
// @grant        GM_addStyle
// @grant        GM_setValue
// @grant        GM_getValue
// @require      https://cdn.jsdelivr.net/npm/markdown-it@14.1.0/dist/markdown-it.min.js
// @require      https://cdn.jsdelivr.net/npm/dompurify@3.1.5/dist/purify.min.js
// ==/UserScript==
```

## 🔧 模块系统

### 简化的模块定义
```javascript
// 立即创建全局对象
window.QQMindMap2Obsidian = {
    test: true,
    version: 'simple',
    status: 'initializing'
};

// 简化的模块系统
const modules = {};
function define(name, factory) { 
    try {
        modules[name] = factory();
        console.log('✅ Module loaded:', name);
    } catch (error) {
        console.error('❌ Error loading module:', name, error);
    }
}
function require(name) { 
    const module = modules[name];
    if (!module) {
        console.error('❌ Module not found:', name);
    }
    return module;
}
```

### 模块加载策略
- **延迟加载**：按需加载模块
- **错误恢复**：处理模块加载失败
- **依赖解析**：自动解析模块依赖
- **缓存机制**：避免重复加载

## 🎨 UI 组件开发

### 用户界面原则
- **非侵入性**：不干扰原有页面功能
- **响应式设计**：适应不同屏幕尺寸
- **用户友好**：提供清晰的交互反馈
- **可访问性**：支持键盘导航和屏幕阅读器

### UI 组件示例
```javascript
// 创建用户界面
function createUI(parentElement) {
    const container = document.createElement('div');
    container.className = 'qq-converter-ui';
    container.innerHTML = `
        <div class="converter-header">
            <h3>QQ Mind Map Converter</h3>
        </div>
        <div class="converter-controls">
            <button id="qq-to-md" class="btn btn-primary">QQ → MD</button>
            <button id="md-to-qq" class="btn btn-secondary">MD → QQ</button>
        </div>
        <div class="converter-status" id="status"></div>
    `;
    
    parentElement.appendChild(container);
    return container;
}
```

### 样式管理
```javascript
// 添加样式
function addStyles() {
    const style = document.createElement('style');
    style.textContent = `
        .qq-converter-ui {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 16px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 10000;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin: 4px;
            font-size: 14px;
        }
        
        .btn-primary {
            background: #007bff;
            color: white;
        }
        
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
    `;
    document.head.appendChild(style);
}
```

## 📋 通知系统

### 用户反馈机制
```javascript
// 通知系统
class NotificationSystem {
    constructor() {
        this.defaultDuration = 3000;
        this.notifications = [];
    }
    
    show(message, type = 'success', duration = this.defaultDuration) {
        const notification = this.createNotification(message, type);
        document.body.appendChild(notification);
        
        this.animateIn(notification);
        
        setTimeout(() => {
            this.animateOut(notification);
        }, duration);
    }
    
    success(message, duration = this.defaultDuration) {
        this.show(message, 'success', duration);
    }
    
    error(message, duration = this.defaultDuration) {
        this.show(message, 'error', duration);
    }
    
    warning(message, duration = this.defaultDuration) {
        this.show(message, 'warning', duration);
    }
    
    info(message, duration = this.defaultDuration) {
        this.show(message, 'info', duration);
    }
}
```

## 🔒 安全考虑

### 内容安全策略
- **DOMPurify 集成**：清理用户输入和输出
- **XSS 防护**：防止跨站脚本攻击
- **数据验证**：验证所有用户输入
- **安全存储**：安全地存储用户设置

### 权限管理
```javascript
// 权限检查
function checkPermissions() {
    const requiredGrants = [
        'GM_setClipboard',
        'GM_addStyle',
        'GM_setValue',
        'GM_getValue'
    ];
    
    const missingGrants = requiredGrants.filter(grant => 
        typeof window[grant] === 'undefined'
    );
    
    if (missingGrants.length > 0) {
        console.error('Missing required grants:', missingGrants);
        return false;
    }
    
    return true;
}
```

## 🧪 测试策略

### 测试架构
- **模块化测试设计**：避免重复生成大量占位符
- **简化设计**：使用 `SimpleTestSuite` 替代复杂的模块系统
- **Tampermonkey适配**：模拟浏览器环境和CDN依赖
- **配置驱动**：通过配置文件统一管理测试行为

### 测试分类
- **基础测试**：核心功能验证
- **边界测试**：边缘情况和错误处理
- **错误测试**：格式错误和异常情况
- **性能测试**：转换速度和资源使用

### 测试用例设计
```javascript
// 基础测试用例示例
const BASE_TEST_DATA = {
    simpleHeader: {
        markdown: `# 标题\n\n这是内容`,
        description: '基础标题结构'
    },
    parallelText: {
        markdown: `# 主标题\n\n第一行正文\n第二行正文`,
        description: '同级文本节点'
    },
    codeBlockWithSpecialChars: {
        markdown: `# 代码块\n\n\`\`\`javascript\nArtist('s )Name\n\`\`\``,
        description: '代码块特殊字符处理'
    }
};

// 边界测试用例示例
const EDGE_CASES = {
    emptyContent: {
        markdown: '',
        description: '空行处理'
    },
    specialCharacters: {
        markdown: `# 特殊字符\n\n<>&"'`,
        description: 'HTML特殊字符转义'
    },
    nestedStructure: {
        markdown: `# 标题1\n## 标题2\n### 标题3\n#### 标题4`,
        description: '深层嵌套结构'
    }
};
```

### 验证方法
```javascript
// 双向转换验证示例
function validateBidirectionalConversion(original, mdToQQ, qqToMD) {
    const errors = [];
    const warnings = [];
    
    // 基础验证
    if (!mdToQQ || !mdToQQ.title) {
        errors.push('MD→QQ 转换结果无效');
    }
    
    if (!qqToMD || typeof qqToMD !== 'string') {
        errors.push('QQ→MD 转换结果无效');
    }
    
    // 内容完整性验证
    if (original.includes('正文') && !qqToMD.includes('正文')) {
        warnings.push('可能丢失了部分内容');
    }
    
    // 结构验证
    if (original.includes('```') && !qqToMD.includes('```')) {
        warnings.push('代码块可能未正确处理');
    }
    
    return { passed: errors.length === 0, errors, warnings };
}
```

## 🚀 性能优化

### 资源加载优化
- **异步加载**：异步加载非关键资源
- **缓存策略**：实现适当的缓存机制
- **代码分割**：按需加载功能模块
- **内存管理**：及时清理不需要的资源

### 错误处理
```javascript
// 全局错误处理
window.addEventListener('error', (event) => {
    console.error('Global error:', event.error);
    
    // 发送错误报告
    if (window.QQMindMap2Obsidian && window.QQMindMap2Obsidian.notifications) {
        window.QQMindMap2Obsidian.notifications.error(
            '发生错误，请检查控制台获取详细信息'
        );
    }
});

// 未处理的 Promise 拒绝
window.addEventListener('unhandledrejection', (event) => {
    console.error('Unhandled promise rejection:', event.reason);
});
```

## 📚 最佳实践

### 开发流程
1. **本地测试**：在本地环境测试功能
2. **浏览器测试**：在目标浏览器中测试
3. **用户反馈**：收集用户反馈并迭代
4. **版本管理**：使用语义化版本控制

### 调试技巧
- **控制台日志**：使用有意义的日志消息
- **错误边界**：实现错误边界处理
- **性能监控**：监控脚本性能
- **用户反馈**：提供用户反馈渠道

### 测试维护
1. **定期更新**：定期更新测试数据
2. **及时修复**：及时修复失败的测试
3. **可读性**：保持测试代码的可读性
4. **变更记录**：记录重要的测试变更
description:
globs:
alwaysApply: false
---
