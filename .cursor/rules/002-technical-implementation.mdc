# 技术实现指导

## 🔧 Markdown-it 令牌处理

### 令牌类型理解
- **内联令牌**：处理文本、链接、强调等内联元素
- **块级令牌**：处理标题、段落、列表、代码块等块级元素
- **嵌套内容**：正确处理复杂的嵌套结构

### 令牌处理模式
```javascript
// 处理内联令牌
function processInlineTokens(tokens) {
    return tokens.map(token => {
        switch (token.type) {
            case 'text': return processTextToken(token);
            case 'link_open': return processLinkToken(token);
            case 'strong_open': return processStrongToken(token);
            default: return token;
        }
    });
}

// 处理块级令牌
function processBlockTokens(tokens) {
    return tokens.map(token => {
        switch (token.type) {
            case 'heading_open': return processHeadingToken(token);
            case 'code_block': return processCodeBlockToken(token);
            case 'list_item_open': return processListItemToken(token);
            default: return token;
        }
    });
}
```

## 🏗️ QQ 思维导图数据结构

### 节点层次结构
- **父子关系**：理解节点间的层级关系
- **同级节点**：正确处理相同层级的节点
- **节点类型**：区分标题、文本、代码块、图片等不同类型
- **节点属性**：处理节点的各种属性和元数据

### 富文本处理
- **格式化文本**：处理带有样式和链接的文本
- **内联格式**：处理粗体、斜体、下划线等格式
- **链接处理**：正确处理内部和外部链接
- **图片数据**：处理图片的尺寸、alt文本和标题

### 注释字段
- **元数据保存**：在 notes 字段中保存额外信息
- **代码块内容**：将代码块内容存储在 notes 中
- **图片信息**：保存图片的完整信息
- **自定义数据**：支持项目特定的元数据

## 📋 转换模式

### 节点转换示例
```javascript
// QQ 节点到 Markdown 转换
function convertNode(node, indent, isListItem) {
    let result = '';
    
    if (node.title && node.title.text) {
        const text = convertRichTextToMarkdown(node.title);
        result += `${indent}${text}\n`;
    }
    
    if (node.children && node.children.attached) {
        for (const child of node.children.attached) {
            result += convertNode(child, indent + '  ', false);
        }
    }
    
    return result;
}
```

### 富文本转换
```javascript
// 富文本到 Markdown 转换
function convertRichTextToMarkdown(titleObject) {
    if (typeof titleObject === 'string') {
        return titleObject;
    }
    
    let result = '';
    if (titleObject.styles) {
        for (const style of titleObject.styles) {
            switch (style.type) {
                case 'bold': result += `**${style.text}**`; break;
                case 'italic': result += `*${style.text}*`; break;
                case 'link': result += `[${style.text}](${style.url})`; break;
                default: result += style.text;
            }
        }
    }
    
    return result || titleObject.text || '';
}
```

## 🎯 特殊内容处理

### 代码块处理
```javascript
// 代码块转换
function convertCodeBlock(node) {
    const notesContent = node.notes?.content;
    if (!notesContent) return '';
    
    // 从 notes 中提取代码内容
    const codeMatch = notesContent.match(/<pre><code>(.*?)<\/code><\/pre>/s);
    if (codeMatch) {
        const codeContent = unescapeHtml(codeMatch[1]);
        const language = extractLanguageFromTitle(node.title);
        return `\`\`\`${language}\n${codeContent}\n\`\`\`\n`;
    }
    
    return '';
}

// 代码块转换示例
function createCodeBlockNode(codeLines, language) {
    const codeContent = codeLines.join('\n');
    const title = language ? `\`\`\`${language}` : '```';
    
    return {
        title: createRichTextNode(title),
        labels: [CODE_BLOCK_LABEL],
        notes: { content: `<pre><code>${escapeHtml(codeContent)}</code></pre>` },
        children: { attached: [] }
    };
}
```

### 图片处理
```javascript
// 图片转换
function convertImage(node) {
    const notesContent = node.notes?.content;
    if (!notesContent) return '';
    
    // 从 notes 中提取图片信息
    const imgMatch = notesContent.match(/<img[^>]+src="([^"]+)"[^>]*>/);
    if (imgMatch) {
        const src = imgMatch[1];
        const alt = extractAltText(notesContent);
        const title = extractTitle(notesContent);
        
        let result = `![${alt}](${src})`;
        if (title) result += ` "${title}"`;
        return result + '\n';
    }
    
    return '';
}
```

### 分割线处理
```javascript
// 分割线转换
function convertDivider(node) {
    if (node.labels && node.labels.includes('divider')) {
        return '---\n';
    }
    return '';
}
```

## 🔍 数据完整性

### 双向转换验证
- 确保 MD→QQ→MD 转换保持数据完整性
- 验证所有重要信息都被保留
- 检查格式和结构的正确性
- 处理转换过程中的数据丢失

### 边缘情况处理
- 处理空节点和无效数据
- 处理复杂的嵌套结构
- 处理不完整或损坏的数据
- 优雅地处理未知的节点类型

### 性能优化
- 优化大文档的处理速度
- 减少内存使用和垃圾回收
- 使用高效的算法进行节点遍历
- 考虑缓存和预计算

## 📚 最佳实践

### 节点遍历
- 使用深度优先遍历处理节点树
- 正确处理节点的层级关系
- 避免无限递归和循环引用
- 优化遍历算法的性能

### 错误处理
- 提供有意义的错误消息
- 优雅地处理格式错误
- 记录转换过程中的问题
- 支持部分转换和错误恢复

### 特殊字符处理
```javascript
// HTML 转义函数
function escapeHtml(text) {
    return text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
}

// HTML 反转义函数
function unescapeHtml(text) {
    return text
        .replace(/&amp;/g, '&')
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/&quot;/g, '"')
        .replace(/&#39;/g, "'");
}
```

### 富文本处理
```javascript
// 富文本转换示例
function createRichTextNode(markdown) {
    const tokens = markdownIt.parse(markdown, {});
    return buildRichTextFromTokens(tokens);
}

function buildRichTextFromTokens(tokens) {
    // 构建富文本结构的逻辑
    // 处理内联格式、链接、图片等
}
```

## 🚀 性能优化

### 缓存策略
- 缓存解析结果以避免重复处理
- 使用流式处理处理大文档
- 优化令牌遍历算法
- 考虑内存使用和垃圾回收

### 学习资源
- **官方文档**：使用 MCP Context7 访问 markdown-it 文档
- **插件生态系统**：探索现有插件以获取灵感
- **令牌处理**：深入了解 markdown-it 的令牌系统
- **最佳实践**：遵循已建立的 markdown 处理模式
description:
globs:
alwaysApply: false
---
