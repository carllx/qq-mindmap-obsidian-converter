# Cursor Rules for QQmindmap2Obsidian Project

## üéØ Core Philosophy: Root Cause Problem Solving

**Always solve problems at their essence, not through superficial workarounds.**

- **Deep Analysis First**: Before implementing any solution, analyze the root cause of the problem
- **Architecture-Driven**: Consider how changes affect the overall system architecture
- **Sustainable Solutions**: Prefer solutions that prevent future problems rather than quick fixes
- **Data Integrity**: Ensure bidirectional conversion maintains complete data fidelity

## üèóÔ∏è Architecture Principles

### Modular Design
- **Single Responsibility**: Each module has one clear purpose
- **Low Coupling**: Minimize dependencies between modules
- **High Cohesion**: Related functionality stays together
- **Template-Driven**: Use template system for maintainable builds

### Code Organization
```
core/
‚îú‚îÄ‚îÄ parsers/     # Data parsing and extraction
‚îú‚îÄ‚îÄ converters/  # Format conversion logic
‚îú‚îÄ‚îÄ utils/       # Shared utilities
‚îî‚îÄ‚îÄ formatters/  # Format-specific processing

ui/              # User interface components
templates/       # Build system templates
test/            # Comprehensive testing
```

## üîß Technical Stack Considerations

### Markdown-it Integration
- **CDN Loading**: Project uses markdown-it via CDN in Tampermonkey
- **Token-Based Processing**: Leverage markdown-it's token system for rich text conversion
- **Plugin Architecture**: Consider markdown-it plugins for extended functionality
- **Context7 Integration**: Use MCP Context7 for markdown-it documentation and best practices

### Conversion Pipeline
1. **Parse**: Extract structure and content using appropriate parsers
2. **Transform**: Convert between formats while preserving semantics
3. **Format**: Apply consistent formatting and styling
4. **Validate**: Ensure bidirectional conversion integrity

## üéØ Problem-Solving Approach

### 1. Root Cause Analysis
- **Why does this problem exist?**
- **What are the underlying data structures?**
- **How do the systems interact?**

### 2. Solution Design
- **Architecture Impact**: How does this affect the overall system?
- **Data Flow**: How does data move through the conversion pipeline?
- **Error Handling**: What can go wrong and how do we handle it?

### 3. Implementation Strategy
- **Incremental**: Build and test in small, verifiable steps
- **Backward Compatible**: Maintain existing functionality
- **Testable**: Every change should be verifiable

## üìã Development Guidelines

### Code Quality
- **Clear Intent**: Code should be self-documenting
- **Consistent Patterns**: Use established patterns across the codebase
- **Error Boundaries**: Handle errors gracefully with meaningful feedback
- **Performance**: Consider the impact on conversion speed and memory usage

### Testing Strategy
- **Unit Tests**: Test individual components in isolation
- **Integration Tests**: Test the full conversion pipeline
- **Edge Cases**: Consider unusual inputs and error conditions
- **Bidirectional**: Ensure MD‚ÜîQQ conversions are reversible

### Documentation
- **Implementation Notes**: Document why decisions were made
- **Architecture Diagrams**: Visualize system relationships
- **Usage Examples**: Provide clear examples of functionality
- **Troubleshooting**: Document common issues and solutions

## üîç Specific Considerations

### Markdown-it Token Processing
- **Token Types**: Understand markdown-it's token structure
- **Inline vs Block**: Handle different token types appropriately
- **Nested Content**: Process complex nested structures correctly
- **Custom Tokens**: Consider custom token types for special content

### QQ Mindmap Data Structure
- **Node Hierarchy**: Understand parent-child relationships
- **Rich Text**: Handle formatted text with styles and links
- **Images**: Process image data with proper dimensions and alt text
- **Notes**: Preserve additional metadata in notes field

### Conversion Challenges
- **Format Preservation**: Maintain original formatting where possible
- **Semantic Meaning**: Preserve the meaning, not just the syntax
- **Edge Cases**: Handle unusual or malformed input gracefully
- **Performance**: Optimize for large documents and complex structures

## üöÄ Innovation Guidelines

### When Adding Features
1. **Analyze the Core Need**: What problem are we really solving?
2. **Consider Architecture**: How does this fit into the existing system?
3. **Plan for Scale**: Will this solution work as the system grows?
4. **Test Thoroughly**: Ensure the solution works in all scenarios

### When Refactoring
1. **Identify Pain Points**: What's causing the current issues?
2. **Preserve Functionality**: Ensure no existing features break
3. **Improve Maintainability**: Make the code easier to understand and modify
4. **Update Documentation**: Keep documentation current with changes

## üìö Learning and Research

### Markdown-it Resources
- **Official Documentation**: Use MCP Context7 to access markdown-it docs
- **Plugin Ecosystem**: Explore existing plugins for inspiration
- **Token Processing**: Deep dive into markdown-it's token system
- **Best Practices**: Follow established patterns for markdown processing

### Architecture Patterns
- **Template Method**: Use templates for consistent structure
- **Strategy Pattern**: Allow different conversion strategies
- **Observer Pattern**: Handle UI updates and notifications
- **Factory Pattern**: Create appropriate objects for different content types

## üéØ Success Metrics

### Code Quality
- **Maintainability**: Code should be easy to understand and modify
- **Testability**: All functionality should be verifiable
- **Performance**: Conversions should be fast and efficient
- **Reliability**: System should handle edge cases gracefully

### User Experience
- **Accuracy**: Conversions should preserve all important information
- **Speed**: Conversions should complete quickly
- **Feedback**: Users should know what's happening and if there are issues
- **Intuitiveness**: The system should work as users expect

---

**Remember**: Every line of code should serve a purpose, every feature should solve a real problem, and every decision should consider the long-term health of the system. 