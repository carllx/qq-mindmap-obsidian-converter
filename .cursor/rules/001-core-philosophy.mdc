# 核心哲学：根本原因问题解决

**始终在本质上解决问题，而不是通过表面的变通方法。**

## 🎯 基本原则

### 深度分析优先
- 在实施任何解决方案之前，分析问题的根本原因
- 理解底层数据结构和系统交互
- 考虑架构影响而非局部修复

### 架构驱动设计
- 考虑变更如何影响整体系统架构
- 优先选择预防未来问题的可持续解决方案
- 确保双向转换保持完整的数据保真度

### 数据完整性
- 确保 MD↔QQ 转换的可逆性
- 保持语义含义而不仅仅是语法
- 处理边缘情况和不寻常输入

## 🏗️ 架构原则

### 模块化设计
- **单一职责**：每个模块都有明确的单一目的
- **低耦合高内聚**：最小化模块间依赖，相关功能保持在一起
- **模板驱动**：使用模板系统进行可维护的构建

### 代码组织结构
```
core/
├── parsers/     # 数据解析和提取
├── converters/  # 格式转换逻辑
├── utils/       # 共享工具
└── formatters/  # 格式特定处理

ui/              # 用户界面组件
templates/       # 构建系统模板
test/            # 综合测试
```

## 🔧 技术栈考虑

### Markdown-it 集成
- **基于令牌的处理**：利用 markdown-it 的令牌系统进行富文本转换
- **插件架构**：考虑 markdown-it 插件以扩展功能
- **Context7 集成**：使用 MCP Context7 获取 markdown-it 文档

### 转换管道
1. **解析**：使用适当的解析器提取结构和内容
2. **转换**：在格式间转换同时保持语义
3. **格式化**：应用一致的格式和样式
4. **验证**：确保双向转换完整性

## 🧪 测试策略

### 测试分类
- **基础测试**：核心功能验证
- **边界测试**：边缘情况和错误处理
- **双向转换验证**：确保 MD↔QQ 转换是可逆的
- **性能测试**：转换速度和资源使用

### 验证方法
```javascript
// 双向转换验证示例
function validateBidirectionalConversion(original, mdToQQ, qqToMD) {
    const errors = [];
    
    // 基础验证
    if (!mdToQQ || !mdToQQ.title) {
        errors.push('MD→QQ 转换结果无效');
    }
    
    if (!qqToMD || typeof qqToMD !== 'string') {
        errors.push('QQ→MD 转换结果无效');
    }
    
    // 内容完整性验证
    if (original.includes('正文') && !qqToMD.includes('正文')) {
        errors.push('可能丢失了部分内容');
    }
    
    return { passed: errors.length === 0, errors };
}
```

## 🚀 创新和重构指导

### 功能设计原则
```javascript
// 功能设计检查清单
function validateFeatureDesign(feature) {
    const checklist = {
        solvesRealProblem: true,      // 解决真实问题
        fitsArchitecture: true,        // 适应架构
        isScalable: true,             // 可扩展
        isTestable: true,             // 可测试
        isMaintainable: true,         // 可维护
        hasClearInterface: true,       // 清晰接口
        followsPatterns: true         // 遵循模式
    };
    
    return Object.values(checklist).every(Boolean);
}
```

### 重构原则
- **保持功能**：确保现有功能不中断
- **改善可维护性**：使代码更易理解和修改
- **更新文档**：保持文档与变更同步
- **包含测试**：每个变更都应该是可验证的

## 🚨 避免打补丁式编程

### 根本原因分析方法
```javascript
// 当遇到问题时，按以下步骤分析：
function analyzeProblem(issue) {
    // 1. 为什么这个问题存在？
    const rootCause = findRootCause(issue);
    
    // 2. 底层数据结构是什么？
    const dataStructure = analyzeDataStructure(issue);
    
    // 3. 系统如何交互？
    const systemInteraction = analyzeSystemInteraction(issue);
    
    // 4. 这个解决方案如何影响整体架构？
    const architecturalImpact = analyzeArchitecturalImpact(solution);
    
    return { rootCause, dataStructure, systemInteraction, architecturalImpact };
}
```

### 解决方案验证
```javascript
// 设计解决方案时的检查清单
function validateSolution(solution) {
    const checklist = {
        solvesRootCause: true,        // 解决根本原因
        fitsArchitecture: true,       // 适应现有架构
        isMaintainable: true,         // 可维护
        isTestable: true,             // 可测试
        isScalable: true,             // 可扩展
        avoidsPatches: true           // 避免打补丁
    };
    
    return Object.values(checklist).every(Boolean);
}
```

## 🎯 成功指标

### 代码质量
- **可维护性**：代码应该易于理解和修改
- **可测试性**：所有功能都应该是可验证的
- **性能**：转换应该快速高效
- **可靠性**：系统应该优雅地处理边缘情况

### 用户体验
- **准确性**：转换应该保留所有重要信息
- **速度**：转换应该快速完成
- **反馈**：用户应该知道发生了什么以及是否有问题
- **直观性**：系统应该按用户期望工作

## 📚 设计模式应用

### 模板方法模式
```javascript
// 转换流程模板
class ConversionTemplate {
    convert(input) {
        const parsed = this.parse(input);
        const transformed = this.transform(parsed);
        const formatted = this.format(transformed);
        return this.validate(formatted);
    }
    
    parse(input) { throw new Error('Must implement parse'); }
    transform(data) { throw new Error('Must implement transform'); }
    format(data) { throw new Error('Must implement format'); }
    validate(data) { throw new Error('Must implement validate'); }
}
```

### 策略模式
```javascript
// 转换策略接口
class ConversionStrategy {
    convert(input) { throw new Error('Must implement convert'); }
    validate(input) { throw new Error('Must implement validate'); }
}
```

---

**记住**：每一行代码都应该有目的，每个功能都应该解决真实问题，每个决策都应该考虑系统的长期健康。 

- **速度**：转换应该快速完成
- **反馈**：用户应该知道发生了什么以及是否有问题
- **直观性**：系统应该按用户期望工作 
